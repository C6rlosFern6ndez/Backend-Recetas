package com.library.recetas.model;

import jakarta.persistence.*;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.ArrayList; // Import for List
import java.util.HashSet; // Import for HashSet
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(name = "usuarios")
@Getter
@Setter
public class Usuario implements UserDetails { // Implementar UserDetails

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "nombre_usuario", nullable = false, unique = true, length = 50)
    private String nombreUsuario;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 255)
    private String contrasena;

    @Column(name = "nombre_completo", length = 100)
    private String nombreCompleto;

    @Column(name = "bio", columnDefinition = "TEXT")
    private String bio;

    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;

    // Using a separate table for websites to avoid issues with JSON serialization/deserialization of complex types in @Column
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "usuario_sitios_web", joinColumns = @JoinColumn(name = "usuario_id"))
    @Column(name = "url", length = 255)
    private List<String> sitiosWeb = new ArrayList<>();

    @Column(name = "fecha_registro", nullable = false, updatable = false)
    private LocalDateTime fechaRegistro;

    // Enum for roles
    @Enumerated(EnumType.STRING)
    @Column(name = "rol_enum", nullable = false)
    private RoleEnum rolEnum; // This will store the primary role

    // Fields for email verification
    @Column(name = "email_verificado", nullable = false, columnDefinition = "BOOLEAN DEFAULT FALSE")
    private boolean emailVerificado = false;

    @Column(name = "verification_token", length = 255)
    private String verificationToken;

    // The 'roles' field (Many-to-Many with Role entity) is removed as per user's request to limit roles to an enum.
    // @ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)
    // @JoinTable(
    //     name = "usuario_roles",
    //     joinColumns = @JoinColumn(name = "usuario_id"),
    //     inverseJoinColumns = @JoinColumn(name = "role_id")
    // )
    // private Set<Role> roles = new HashSet<>();

    @JsonManagedReference
    @OneToMany(mappedBy = "usuario", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<Receta> recetas;

    @JsonManagedReference
    @OneToMany(mappedBy = "usuario", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<Comentario> comentarios;

    @JsonManagedReference
    @OneToMany(mappedBy = "usuario", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<Calificacion> calificaciones;

    public Usuario() {
        this.fechaRegistro = LocalDateTime.now(); // Set default on creation
    }

    public Usuario(String nombreUsuario, String email, String contrasena) {
        this.nombreUsuario = nombreUsuario;
        this.email = email;
        this.contrasena = contrasena;
        this.fechaRegistro = LocalDateTime.now();
        this.emailVerificado = false; // New users are not verified by default
    }

    // Getters and Setters are automatically generated by Lombok @Getter/@Setter
    // Explicitly defining them here for clarity and to show where they would go if not using Lombok.
    // However, Lombok's generated ones will be used.

    // Explicitly defining setContrasena to resolve the compilation error.
    public void setContrasena(String contrasena) {
        this.contrasena = contrasena;
    }

    // MÃ©todos de UserDetails
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // Convert roles to SimpleGrantedAuthority using the enum
        Set<SimpleGrantedAuthority> authorities = new HashSet<>();
        if (this.rolEnum != null) {
            authorities.add(new SimpleGrantedAuthority(this.rolEnum.name()));
        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return contrasena;
    }

    @Override
    public String getUsername() {
        return email; // Usamos el email como nombre de usuario para Spring Security
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        // A user is enabled only if their email is verified
        return this.emailVerificado;
    }
}
